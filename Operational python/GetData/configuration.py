#######################################################
# 
# configuration.py
# Python implementation of the Class Configuration
# Generated by Enterprise Architect
# Created on:      24-May-2016 12:58:20
# Original author: Jane
# 
#######################################################

import datetime
import configFileManager

"""
NAME
    configuration - implementation of class
FILE
    configuration.py
CLASSES
    Configuration
"""


class Configuration:
    """
    Class to set up paths and URLs to find required data. Also dataset type and tile, plus
    time period. Requires a configFileManager object in constructor.

    Methods defined here:
        get_config(...)
            Loads config from file.

        set_args(...)
            Initialise config explicitly.

        get_tile(...)
            Retrieve tile name.

        create_filename(...)
            Concatenate parts to form file name.

        next_day(...)
            Iterate day used.

        is_valid_day(...)
            Check day in range of start-end.

        create_URL(...)
            Concatenate parts to from URL.

    ----------------------------------------------------------------------
    No data or other attributes defined here.

    """

    def __init__(self, mngr):
        """
        Initialise all attributes to empty values, keep pointer to the configFileManager.
        :param mngr: instantiated configFileManager object.
        :return: no return
        """
        self.m_ConfigFileManager = mngr
        self.m_product = ""
        self.m_tile = ""
        self.m_year = ""
        self.m_DoY = []
        self.m_end_day = 0
        self.m_day_counter = 0

    def get_config(self):
        """
        Reads in saved configuration details.

        File handling is delegated: settings are retrieved and stored as instance
        attributes.

        :return: no return
        :raise: IOError if the default config. file is not found.
        """
        try:
            self.m_ConfigFileManager.load_XML()  # this will raise exception if no data is available
            params = self.m_ConfigFileManager.get_config()
            self.set_args(params[0], params[1], params[2], params[3])
        except IOError:
            # if there is no saved config, need to tell the caller
            raise
        pass

    def get_tile(self):
        """
        Get instance property: time name

        :return: tile name
        """
        return self.m_tile

    def set_args(self, product, year, tile, DoY):
        """
        Set instance properties for retrieving required data file.

        Data archive is at https://lpdaac.usgs.gov/dataset_discovery/modis/modis_products_table.
        If an end day of year is not specified, 365 is used.

        :param product: MOD* and MYD* supported
        :param year: valid year in data archive
        :param tile: valid tile in data archive
        :param DoY: starting day of year, and optionally also end
        :return: no return
        """
        self.m_product = product
        self.m_tile = tile
        self.m_year = year
        self.m_DoY = DoY
        self.m_day_counter = self.m_DoY[0]
        if len(self.m_DoY) == 2:
            self.m_end_day = self.m_DoY[1]
        else:
            self.m_end_day = 365
        self.__set_constants()

    def __set_constants(self):
        """
        Set instance properties for constants.
        :return: no return
        """
        self.m_version = "005"
        if str(self.m_product).startswith('MOD'):
            self.m_data_dir = "MOLT"
            self.m_time_step = 1
        elif str(self.m_product).startswith('MYD'):
            self.m_data_dir = "MOLA"
            self.m_time_step = 1
        else:
            self.m_data_dir = "MOTA"
            self.m_time_step = 8

    def create_filename(self):
        """
        Construct name for retrieved file.

        Uses settings/parameters which define the file to be downloaded.

        :return: file name
        """
        filename = (self.m_product + '.A' + str(self.m_year) + '{0:03d}'.format(self.m_day_counter) +
                    '.' + self.m_tile + '.' + self.m_version + '*hdf')
        return filename

    def is_valid_day(self):
        """
        Check whether the day of year is within the start-end range.

        :return: True if day is within range, False otherwise
        """
        if self.m_day_counter <= self.m_end_day:
            return True
        else:
            return False

    def next_day(self):
        """
        Increments the day of year counter by the time step resolution.

        :return: no return
        """
        self.m_day_counter += self.m_time_step

    def create_URL(self):
        """
        Create the web page address to use.

        Uses settings/parameters which define the web page to access.

        :return: URL string
        """
        # convert current DoY into a date
        date = datetime.datetime(self.m_year, 1, 1) + datetime.timedelta(self.m_day_counter - 1)
        # create string
        web_string = ('http://e4ftl01.cr.usgs.gov/' + self.m_data_dir + '/' + self.m_product +
                      '.' + self.m_version + '/' + date.strftime('%Y.%m.%d'))
        return web_string



#    def set_time_period(self):
#         """
#
#         :return:
#         """
#         """Note Python datetime class can turn day of year into date:
#         > datetime.datetime(year, 1, 1) + datetime.timedelta(days - 1)
#         Then datetime methods to output in whatever format required.  or
#         > import datetime
#         > datetime.datetime.strptime('2010 120', '%Y %j')
#             datetime.datetime(2010, 4, 30, 0, 0)
#         > _.strftime('%d/%m/%Y')
#             '30/04/2010'
#         """
#        pass