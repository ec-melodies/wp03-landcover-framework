#######################################################
# 
# configuration.py
# Python implementation of the Class Configuration
# Generated by Enterprise Architect
# Created on:      24-May-2016 12:58:20
# Original author: Jane
# 
#######################################################

import datetime
import os
import json
import configparser

import constants as const
import GetData.src.LPDAAC_website as webSrc

"""
NAME
    configuration - implementation of class
FILE
    configuration.py
CLASSES
    Configuration
"""

class Configuration:
    """
    Class to set up paths and URLs to find required data. Also dataset type and tile, plus
    time period. Also to get the configuration from a saved file in INI format.

    Methods defined here:
        read_config(...)
            Loads config from file.

        set_directory(...)
            Creates specified folder if necessary.

        get_tile(...)
            Retrieve tile name.

        get_user(...)
            Retrieve user name.

        get_passwd(...)
            Retrieve user's password.

        create_local_filenames(...)
            Concatenate parts to form file name.

        next_day(...)
            Iterate day used.

        is_valid_day(...)
            Check day in range of start-end.

        create_URL(...)
            Concatenate parts to form web page address.


    ----------------------------------------------------------------------
    Attributes defined here:
        All settings needed to retrieve specific data file.

    """

    def __init__(self):
        """
        Initialise all attributes to empty values.

        :return: no return
        """
        self.cfg = configparser.ConfigParser()  # parser object to read INI file
        self.m_product = ""                     # product required - either 'MOD' or 'MYD'
        self.m_tile = ""                        # specific tile required
        self.m_year = -1                        # year data is required for
        self.m_DoY = -1                         # start day to get data files for
        self.m_user = ""                        # login details for LPDACC site
        self.m_passwd = ""                      # login details for LPDACC site
        self.m_config = const.defs['file']      # this default is a valid file
        self.m_data_store = ""                  # optional location for user to place downloaded files
        self.m_processed_data = ""              # optional location for user to place processed data files
        self.m_end_day = 0                      # end day for data retrieval (default 365)
        self.m_day_counter = 0                  # incremental day counter for iterating data archive
        self.m_web_data_dir = ""                    # used in creating URL for data location
        self.m_version = ""                     # used in creating URL for data location
        self.m_time_step = 0                    # time step for incrementing the day counter according to product
        self.m_nproc = 0                        # number of processes to spawn for gdal manipulation

    def read_config(self, mode, config_file):
        """
        Reads in saved configuration details.

        Settings are retrieved and stored as instance attributes.

        :param mode: indicates which part of the config should be used: download (0)
         or MODISprocess (1)
        :return: no return
        :raise: IOError if the config. file is not found.
        """
        try:
            if config_file != self.m_config:
                self.m_config = config_file
            f = open(self.m_config)
            self.cfg.read_file(f)

            if mode == 0:
                section = self.cfg['download']
                self.m_user = section.get('user')
                self.m_passwd = section.get('password')
                if self.m_user is None or self.m_passwd is None:
                    raise RuntimeError

            elif mode == 1:
                section = self.cfg['MODISprocess']
                self.m_nproc = section.getint('nproc', 1)

            # tile & product need to be set for the data directory for both modes
            # but may be over-ridden by default section
            self.m_product = section.get('product')
            self.m_tile = section.get('tile')
            if self.m_product is None or self.m_tile is None:
                    raise RuntimeError
            self.set_rawdata_dir(section.get('datastore'))

            if mode == 1:
                self.set_gdal_dir(section.get('processed'))

            self.m_year = section.getint('year')
            if self.m_tile is None or self.m_year is None:
                raise RuntimeError

            self.m_DoY = section.getint('DoYstart', 1)
            self.m_end_day = section.getint('DoYend', 365)
            self.m_day_counter = self.m_DoY

            self.__set_constants()

            f.close()

        except IOError as io_err:
            # if there is no saved config, need to tell the caller
            raise io_err

    def set_rawdata_dir(self, dir):
        """
        Creates folder specified.
        :param dir: Valid name for a directory.
        :return: no return
        """
        if str(dir) != '' and dir is not None:
            # ensure path separators are standardised, and append separator
            self.m_data_store = str(dir).replace("\\", os.path.sep) + os.path.sep
        else:
            self.m_data_store = os.path.expanduser('~') + os.path.sep + 'data' + os.path.sep

        self.m_data_store += self.m_tile + os.path.sep + self.m_product + os.path.sep

        # ensure the directories are made
        if not os.path.exists(self.m_data_store):
            os.makedirs(self.m_data_store)
            os.chmod(self.m_data_store, 0777)

    def get_rawdata_dir(self):
        return self.m_data_store

    def set_gdal_dir(self, dir):
        if str(dir) != '' and dir is not None:
            self.m_processed_data = os.getcwd() + os.path.sep + \
                                    str(dir).replace("\\", os.path.sep) + os.path.sep
        else:
            self.m_processed_data = self.m_data_store + 'VRTs' + os.path.sep

        if not os.path.exists(self.m_processed_data):
            os.makedirs(self.m_processed_data)

    def get_gdal_dir(self):
        return self.m_processed_data

    def get_tile(self):
        """
        Get instance property: tile name

        :return: tile name
        """
        return self.m_tile

    def get_user(self):
        """
        Get instance property: user name

        :return: user name
        """
        return self.m_user

    def get_passwd(self):
        """
        Get instance property: user's password

        :return: password
        """
        return self.m_passwd

    def get_product(self):
        return self.m_product

    def get_year(self):
        return self.m_year

    def get_doy_range(self):
        return self.m_DoY, self.m_end_day

    def get_num_proc(self):
        return self.m_nproc

    def __set_constants(self):
        """
        Set instance properties for constants.
        :return: no return
        """
        self.m_version = const.data_version                     # "005"
        if str(self.m_product).startswith(const.product_MOD):   # 'MOD'):
            self.m_web_data_dir = const.data_dir_MOD                # "MOLT"
            self.m_time_step = const.timestep_MOD               # 1
        elif str(self.m_product).startswith(const.product_MYD): # 'MYD'):
            self.m_web_data_dir = const.data_dir_MYD                # "MOLA"
            self.m_time_step = const.timestep_MYD               # 1
        else:
            self.m_web_data_dir = const.data_dir_other              # "MOTA"
            self.m_time_step = const.timestep_other             # 8

    def create_local_filenames(self):
        """
        Construct name for retrieved files, and make subdirectories as needed.

        Uses settings/parameters which define the file to be downloaded. Creates names for data and xml files.

        :return: file names for data and xml
        """
        local_filenames = []
        local_filename = ''
        if str(self.m_data_store) != "":
            # prepend path to filename
            local_filename = self.m_data_store
        # TODO remove these horrible hard-coded values
        local_filename += (self.m_product + '.A' + str(self.m_year) + '{0:03d}'.format(self.m_day_counter) +
                           '.' + self.m_tile + '.' + self.m_version + '.hdf')

        local_filenames.append(local_filename)
        local_filename += str('.xml')
        local_filenames.append(local_filename)

        return local_filenames

    def is_valid_day(self):
        """
        Check whether the day of year is within the start-end range.

        :return: True if day is within range, False otherwise
        """
        #print ("Day counter {}".format(self.m_day_counter))
        if self.m_day_counter <= self.m_end_day:
            return True
        else:
            return False

    def next_day(self):
        """
        Increments the day of year counter by the time step resolution.

        :return: no return
        """
        self.m_day_counter += self.m_time_step

    def create_URL(self):
        """
        Create the web page address to use.

        Uses settings/parameters which define the web page to access.

        :return: URL string
        """
        # convert current DoY into a date
        date = datetime.datetime(self.m_year, 1, 1) + datetime.timedelta(self.m_day_counter - 1)
        # create string
        web_string = (webSrc.data_addr_root + self.m_web_data_dir + '/' + self.m_product +
                      '.' + self.m_version + '/' + date.strftime('%Y.%m.%d'))
        return web_string
